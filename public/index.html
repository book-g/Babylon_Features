<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Learn & Practice Notes</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <!-- Include Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <!-- Include Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <!-- Include JavaScript and Markup (HTML) support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>

    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.10/codemirror.min.css">

    <!-- CodeMirror JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.10/codemirror.min.js"></script>

    <!-- CodeMirror JavaScript Mode for JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.10/mode/javascript/javascript.min.js"></script>



</head>

<body>
    <!-- <canvas id="renderCanvas"></canvas>
    <nav>
        <button id="scene1">Load Scene 1</button>
        <button id="scene2">Load Scene 2</button>
    </nav> -->
    <!-- <script src="js/common.js"></script>
    <script src="js/main.js"></script>
    <script src="js/map_pattern.js"></script>
    <script src="js/hierarchy.js"></script>

    <div id="hierarchicalStructure"></div> -->

    <!-- Main content -->
    <script src="js/code_1_25.js"></script>
    <script src="js/code_26_50.js"></script>
    <script src="js/code_51_75.js"></script>


    <script src="js/map_pattern.js"></script>
    <script src="js/page_mapper.js"></script>
    <script src="js/code_list.js"></script>
    <script src="js/hierarchy.js"></script>
    <script src="js/common.js"></script>



    <div id="mySidebar" class="sidebar">
        Gobal Krishnan V <br>
        <address>gobalkrishnan.books@gmail.com</address>

        <div id="hierarchicalStructure"></div>
    </div>

    <div id="main">


        <canvas id="renderCanvas"></canvas>


        <!-- Code Modal -->
        <div id="codeModal">
            <button id="closeCodeModal">Close</button>

            <!-- <pre id="codeDisplay"><code class="language-javascript">// Code will appear here</code></pre>
       -->
            <div id="codeEditor"></div>
            <button id="runCodeButton">Run Code</button>

        </div>

        <!-- View Code Button -->
        <button id="toggleCodeButton">View Code</button>





        <button id="toggleButton" class="toggle-btn">☰</button>
        <!-- <div id="canvasZone"><canvas id="renderCanvas"></canvas></div> -->



    </div>



    <script>
        // Toggle the sidebar
        function toggleSidebar() {
            var sidebar = document.getElementById("mySidebar");
            var main = document.getElementById("main");
            var button = document.getElementById("toggleButton");

            var width = "400px";
            if (sidebar.style.width === width) {
                // Close the sidebar
                sidebar.style.width = "0";
                main.style.marginLeft = "0";
                button.textContent = "☰";
            } else {
                // Open the sidebar
                sidebar.style.width = width;
                main.style.marginLeft = width;
                button.textContent = "x";
            }
        }

        // Attach toggle function to the button
        document.getElementById("toggleButton").addEventListener("click", toggleSidebar);
    </script>

    <script>
        var test1 = `
var createScene = function () {
    // Create the scene
    var scene = new BABYLON.Scene(engine);

    // Set the background color to white
    scene.clearColor = new BABYLON.Color4(1, 1, 1, 1); // RGBA for white

    // Add a camera
    var camera = new BABYLON.ArcRotateCamera(
        "camera",
        -Math.PI / 2,
        Math.PI / 2.5,
        50,
        new BABYLON.Vector3(0, 0, 0)
    );
    camera.attachControl(canvas, true);

    // Add a light
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

    //var music = new BABYLON.Sound("cello", "sound/16.wav", scene, null, { loop: true, autoplay: true,volume:1 });

   
    
    // Load the 3D model
    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "house_dancing.glb", scene)
        .then((result) => {
            var dude = result.meshes[0]; // The root mesh
            dude.scaling = new BABYLON.Vector3(10.0, 10.0, 10.0);

            // Center the object
            var boundingInfo = dude.getBoundingInfo();
            var center = boundingInfo.boundingBox.centerWorld;

            // Translate the object to center it
            dude.position = dude.position.subtract(center);

            // Begin animation if skeletons are available
            if (result.skeletons.length > 0) {
                scene.beginAnimation(result.skeletons[0], 0, 100, true, 1.0);
            }

            // Add Text Overlay
            addOverlayText(scene);
        })
        .catch((error) => {
            console.error("Failed to load model:", error);
        });

    return scene;
};

// Function to add overlay text
function addOverlayText(scene) {
    // Create an advanced dynamic texture for overlay
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    // Add the "Babylon.js" text with gradient
    var babylonText = new BABYLON.GUI.TextBlock();
    babylonText.text = "Babylon.js";
    babylonText.color = "black";
    babylonText.fontSize = "50px";
    babylonText.fontWeight = "bold";
    babylonText.top = "200px"; // Position below the model
    advancedTexture.addControl(babylonText);

    // Add "Gobal Krishnan V" text
    var nameText = new BABYLON.GUI.TextBlock();
    nameText.text = "Gobal Krishnan V";
    nameText.color = "black";
    nameText.fontSize = "20px";
    nameText.top = "250px"; // Position below the Babylon.js text
    advancedTexture.addControl(nameText);

    // Add email text
    var emailText = new BABYLON.GUI.TextBlock();
    emailText.text = "gobalkrishnan.books@gmail.com";
    emailText.color = "gray";
    emailText.fontSize = "15px";
    emailText.top = "280px"; // Position below the name
    advancedTexture.addControl(emailText);
}
//orange
`;
        var c1 =
            `var createScene = function () {
        // This creates a basic Babylon Scene object (non-mesh)
        var scene = new BABYLON.Scene(engine);
    
        // This creates and positions a free camera (non-mesh)
        var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    
        // This targets the camera to scene origin
        camera.setTarget(BABYLON.Vector3.Zero());
    
        // This attaches the camera to the canvas
        camera.attachControl(canvas, true);
    
        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    
        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 0.7;
    
        // Our built-in 'ground' shape.
        var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    
        return scene;
    }; `;


        var test2 = `
    // Create the scene function
var createScene = function () {
    var scene = new BABYLON.Scene(engine);

    // Add a basic camera
    var camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 5, -10), scene);
    camera.attachControl(canvas, true);
    camera.speed = 0.2; // Adjust camera speed

    // Add a basic light
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Create a ground
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 20, height: 20 }, scene);

    // Create a player (sphere)
    var player = BABYLON.MeshBuilder.CreateSphere("player", { diameter: 1 }, scene);
    player.position.y = 1; // Position above the ground

    // Enable physics
    var gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    var physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);

    // Apply physics to the player and ground
    player.physicsImpostor = new BABYLON.PhysicsImpostor(
        player,
        BABYLON.PhysicsImpostor.SphereImpostor,
        { mass: 1, restitution: 0.2 },
        scene
    );

    ground.physicsImpostor = new BABYLON.PhysicsImpostor(
        ground,
        BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, restitution: 0.9 },
        scene
    );

    // Player controls
    var inputMap = {};
    scene.actionManager = new BABYLON.ActionManager(scene);

    // Track key actions
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type === "keydown";
    }));

    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type === "keydown";
    }));

    // Movement variables
    var speed = 5;
    var jumpForce = 8;
    let canJump = true;

    scene.onBeforeRenderObservable.add(() => {
        var deltaTime = engine.getDeltaTime() / 1000; // Convert to seconds

        let moveDirection = new BABYLON.Vector3.Zero();

        if (inputMap["w"] || inputMap["ArrowUp"]) {
            moveDirection.z += 1;
        }
        if (inputMap["s"] || inputMap["ArrowDown"]) {
            moveDirection.z -= 1;
        }
        if (inputMap["a"] || inputMap["ArrowLeft"]) {
            moveDirection.x -= 1;
        }
        if (inputMap["d"] || inputMap["ArrowRight"]) {
            moveDirection.x += 1;
        }

        // Normalize the direction to avoid faster diagonal movement
        moveDirection = moveDirection.normalize().scale(speed * deltaTime);

        // Apply movement
        player.moveWithCollisions(moveDirection);

        // Jump logic
        if (inputMap[" "] && canJump) { // Space bar
            player.physicsImpostor.applyImpulse(
                new BABYLON.Vector3(0, jumpForce, 0),
                player.getAbsolutePosition()
            );
            canJump = false;
        }

        // Check if player is on the ground
        var playerPos = player.position.y.toFixed(2); // Approximate to avoid precision errors
        if (playerPos <= 1.01) {
            canJump = true;
        }
    });

    return scene;
};


`;

        var test3 = `
var createScene = function () {
    var scene = new BABYLON.Scene(engine);

    // Create a light and enable shadows
    var light = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
    light.position = new BABYLON.Vector3(10, 10, 10);
    var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);

    // Create a ground with shadows
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 50, height: 50 }, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.5);
    ground.material = groundMaterial;
    ground.receiveShadows = true;

    // Initialize variables for player and animations
    let player, walkAnimation, idleAnimation;

    // Load the animated model
    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "Soldier.glb", scene)
        .then(function (result) {
            player = result.meshes[0];
            player.position = new BABYLON.Vector3(0, 0, 0);
            player.scaling = new BABYLON.Vector3(1, 1, 1);

            // Add animations
            var playerAnimations = result.animationGroups;
            idleAnimation = playerAnimations.find((anim) => anim.name === "Idle");
            walkAnimation = playerAnimations.find((anim) => anim.name === "Walk");

            // Start idle animation by default
             if (idleAnimation) {
            idleAnimation.start(true);
        } else {
            console.warn("Idle animation not found!");
        }

        if (!walkAnimation) {
            console.warn("Walk animation not found!");
        }

            // Create the follow camera
            var camera = new BABYLON.FollowCamera("FollowCamera", player.position.add(new BABYLON.Vector3(0, 5, -10)), scene);
            camera.radius = 10; // Distance from player
            camera.heightOffset = 5; // Height above the player
            camera.rotationOffset = 0; // Angle to follow
            camera.attachControl(canvas, true);

            // Player movement
            var keys = {
                forward: false,
                backward: false,
                left: false,
                right: false,
            };

            var moveSpeed = 0.1;

            // Handle key press
            window.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "w":
                        keys.forward = true;
                        break;
                    case "s":
                        keys.backward = true;
                        break;
                    case "a":
                        keys.left = true;
                        break;
                    case "d":
                        keys.right = true;
                        break;
                }
            });

            // Handle key release
            window.addEventListener("keyup", (event) => {
                switch (event.key) {
                    case "w":
                        keys.forward = false;
                        break;
                    case "s":
                        keys.backward = false;
                        break;
                    case "a":
                        keys.left = false;
                        break;
                    case "d":
                        keys.right = false;
                        break;
                }
            });

            // Update the scene
            scene.onBeforeRenderObservable.add(() => {
                let moving = false;

                if (keys.forward) {
                    player.position.z += moveSpeed;
                    moving = true;
                }
                if (keys.backward) {
                    player.position.z -= moveSpeed;
                    moving = true;
                }
                if (keys.left) {
                    player.position.x -= moveSpeed;
                    moving = true;
                }
                if (keys.right) {
                    player.position.x += moveSpeed;
                    moving = true;
                }

                // Play animations
                if (moving) {
                    if (!walkAnimation.isPlaying) {
                        idleAnimation.stop();
                        walkAnimation.start(true);
                    }
                } else {
                    if (!idleAnimation.isPlaying) {
                        walkAnimation.stop();
                        idleAnimation.start(true);
                    }
                }

                // Update camera position to follow player
                camera.target = player.position;
            });
        })
        .catch(function (error) {
            console.error("Failed to load the model:", error);
        });

    return scene;
};

`;

        var test4 = `
var createScene = function () {
    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.);

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FollowCamera("FollowCamera", new BABYLON.Vector3(0, 5, -10), scene);
    camera.fov = 1.6;

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    // Initialize variables for character and animations
    let character, walkAnimation, idleAnimation, runAnimation;
    var moveSpeed = 0.1;
    var runSpeed = 0.2;
    var keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        run: false,
    };

    // Load the environment (ground and other assets)
    BABYLON.SceneLoader.ImportMeshAsync(
        "",
        "https://raw.githubusercontent.com/CedricGuillemet/dump/master/LMTuto/",
        "lmScene.glb",
        scene
    ).then(() => {
        var lightmap = new BABYLON.Texture("https://raw.githubusercontent.com/CedricGuillemet/dump/master/LMTuto/Lightmap.jpg");

        // Meshes using the lightmap
        var lightmapped = ["Cube_primitive0", "Cube_primitive1"];
        lightmapped.forEach((meshName) => {
            var mesh = scene.getMeshByName(meshName);
            if (mesh) {
                mesh.isPickable = false;
                mesh.material.lightmapTexture = lightmap;
                mesh.material.useLightmapAsShadowmap = true;
                mesh.material.lightmapTexture.uAng = Math.PI;
                mesh.material.lightmapTexture.level = 1.6;
                mesh.material.lightmapTexture.coordinatesIndex = 1;
                mesh.freezeWorldMatrix();
                mesh.doNotSyncBoundingInfo = true;
            }
        });
    });

    // Load the character model
    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "Soldier.glb", scene).then((result) => {
        character = result.meshes[0];
        character.position = new BABYLON.Vector3(0, 0, 0);
        character.scaling = new BABYLON.Vector3(1, 1, 1);

        // Attach the camera to follow the character
        camera.lockedTarget = character;

        // Load animations
        var characterAnimations = result.animationGroups;
        idleAnimation = characterAnimations.find((anim) => anim.name === "Idle");
        walkAnimation = characterAnimations.find((anim) => anim.name === "Walk");
        runAnimation = characterAnimations.find((anim) => anim.name === "Run");

        // Start idle animation by default
        if (idleAnimation) {
            idleAnimation.start(true);
        }

        // Event listeners for movement
        window.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = true;
                    break;
                case "s":
                    keys.backward = true;
                    break;
                case "a":
                    keys.left = true;
                    break;
                case "d":
                    keys.right = true;
                    break;
                case "Shift":
                    keys.run = true;
                    break;
            }
        });

        window.addEventListener("keyup", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = false;
                    break;
                case "s":
                    keys.backward = false;
                    break;
                case "a":
                    keys.left = false;
                    break;
                case "d":
                    keys.right = false;
                    break;
                case "Shift":
                    keys.run = false;
                    break;
            }
        });

        // Update the scene for movement and animations
        scene.onBeforeRenderObservable.add(() => {
            if (!character) return;

            let moving = false;
            let currentSpeed = keys.run ? runSpeed : moveSpeed;

            // Handle movement
            if (keys.forward) {
                character.position.z += currentSpeed;
                moving = true;
            }
            if (keys.backward) {
                character.position.z -= currentSpeed;
                moving = true;
            }
            if (keys.left) {
                character.position.x -= currentSpeed;
                moving = true;
            }
            if (keys.right) {
                character.position.x += currentSpeed;
                moving = true;
            }

            // Handle animations
            if (moving) {
                if (keys.run) {
                    if (runAnimation && !runAnimation.isPlaying) {
                        idleAnimation?.stop();
                        walkAnimation?.stop();
                        runAnimation.start(true);
                    }
                } else {
                    if (walkAnimation && !walkAnimation.isPlaying) {
                        idleAnimation?.stop();
                        runAnimation?.stop();
                        walkAnimation.start(true);
                    }
                }
            } else {
                if (idleAnimation && !idleAnimation.isPlaying) {
                    walkAnimation?.stop();
                    runAnimation?.stop();
                    idleAnimation.start(true);
                }
            }
        });
    });

    return scene;
};

`;

        var test5 = `
var createScene = function () {
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.0);

    // Enable physics
    scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), new BABYLON.CannonJSPlugin());

    // Camera Setup
    //var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 5, -10), scene);
    var camera = new BABYLON.FollowCamera("FollowCamera", new BABYLON.Vector3(0, 5, -10), scene);

    camera.attachControl(canvas, true);
    

    // Lighting
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Ground Setup
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 50, height: 50 }, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.5);
    ground.material = groundMaterial;
    ground.checkCollisions = true;

    // Stairs Setup
    var stairs = BABYLON.MeshBuilder.CreateBox("stairs", { width: 4, height: 1, depth: 6 }, scene);
    stairs.position = new BABYLON.Vector3(0, 0.5, 5);
    stairs.checkCollisions = true;

    // Character Setup
    let player, walkAnimation, idleAnimation, runAnimation, jumpAnimation;
    let isJumping = false;
    let verticalVelocity = 0;

    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "Soldier.glb", scene).then((result) => {
        player = result.meshes[0];
        player.position = new BABYLON.Vector3(0, -0.5, 0);
        player.scaling = new BABYLON.Vector3(1, 1, 1);
    camera.lockedTarget = player; // The target object to follow

        // Attach Ellipsoid for Collisions
        player.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);
        player.ellipsoidOffset = new BABYLON.Vector3(0, 1, 0);
        player.checkCollisions = true;

        // Load animations
        var animations = result.animationGroups;
        idleAnimation = animations.find((anim) => anim.name === "Idle");
        walkAnimation = animations.find((anim) => anim.name === "Walk");
        runAnimation = animations.find((anim) => anim.name === "Run");
        jumpAnimation = animations.find((anim) => anim.name === "Jump");

        // Start idle animation by default
        if (idleAnimation) idleAnimation.start(true);

        // Movement Logic
        var keys = { forward: false, backward: false, left: false, right: false, run: false, jump: false };
        var moveSpeed = 0.1;
        var runSpeed = 0.2;

        window.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = true;
                    break;
                case "s":
                    keys.backward = true;
                    break;
                case "a":
                    keys.left = true;
                    break;
                case "d":
                    keys.right = true;
                    break;
                case "Shift":
                    keys.run = true;
                    break;
                case " ":
                    if (!isJumping) {
                        keys.jump = true;
                        isJumping = true;
                        verticalVelocity = 0.2; // Initial jump velocity
                    }
                    break;
            }
        });

        window.addEventListener("keyup", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = false;
                    break;
                case "s":
                    keys.backward = false;
                    break;
                case "a":
                    keys.left = false;
                    break;
                case "d":
                    keys.right = false;
                    break;
                case "Shift":
                    keys.run = false;
                    break;
            }
        });

        // Animation and Movement Logic
        scene.onBeforeRenderObservable.add(() => {
            let moving = false;
            var currentSpeed = keys.run ? runSpeed : moveSpeed;

            var direction = new BABYLON.Vector3(
                (keys.left ? -1 : 0) + (keys.right ? 1 : 0),
                0,
                (keys.forward ? 1 : 0) + (keys.backward ? -1 : 0)
            );
            direction.normalize();

            if (direction.length() > 0) {
                moving = true;

                // Move player
                player.moveWithCollisions(direction.scale(currentSpeed));

                // Rotate player to face movement direction
                player.rotation.y = Math.atan2(direction.x, direction.z);
            }

            // Handle jumping
            if (keys.jump) {
                jumpAnimation?.start(true);
                keys.jump = false;
            }

            if (isJumping) {
                player.position.y += verticalVelocity;
                verticalVelocity -= 0.01; // Gravity effect

                if (player.position.y <= 1) {
                    player.position.y = 1;
                    isJumping = false;
                    verticalVelocity = 0;

                    // Return to idle or walk/run animation
                    if (!moving) idleAnimation?.start(true);
                }
            }

            // Play animations based on movement
            if (moving && !isJumping) {
                if (keys.run) {
                    if (runAnimation && !runAnimation.isPlaying) {
                        idleAnimation?.stop();
                        walkAnimation?.stop();
                        runAnimation.start(true);
                    }
                } else {
                    if (walkAnimation && !walkAnimation.isPlaying) {
                        idleAnimation?.stop();
                        runAnimation?.stop();
                        walkAnimation.start(true);
                    }
                }
            } else if (!isJumping) {
                if (!idleAnimation.isPlaying) {
                    walkAnimation?.stop();
                    runAnimation?.stop();
                    idleAnimation.start(true);
                }
            }
        });
    });

    return scene;
};

`;

        var test6 = `var createScene = function () {
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.0);

    // Enable physics with gravity
    var gravityVector = new BABYLON.Vector3(0, -9.8, 0); // Earth's gravity
    var physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);
        scene.collisionsEnabled = true;


    // Camera Setup
    var camera = new BABYLON.FollowCamera("FollowCamera", new BABYLON.Vector3(0, 5, -10), scene);
    camera.attachControl(canvas, true);

    // Lighting
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Ground Setup
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 50, height: 50 }, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.5);
    ground.material = groundMaterial;
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(
        ground,
        BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, friction: 0.5, restitution: 0.7 },
        scene
    ); // Static ground
        ground.checkCollisions = true;



    // Stairs Setup
    var stairs = BABYLON.MeshBuilder.CreateBox("stairs", { width: 4, height: 1, depth: 6 }, scene);
    stairs.position = new BABYLON.Vector3(0, 0.5, 5);
    stairs.physicsImpostor = new BABYLON.PhysicsImpostor(
        stairs,
        BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, friction: 0.5, restitution: 0.7 },
        scene
    ); // Static stairs

        stairs.checkCollisions = true;



    // Character Setup
    let player, walkAnimation, idleAnimation, runAnimation, jumpAnimation;

    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "Soldier.glb", scene).then((result) => {
        player = result.meshes[0];
        player.position = new BABYLON.Vector3(0, 1, 0);
        player.scaling = new BABYLON.Vector3(1, 1, 1);
        player.checkCollisions = true;

        camera.lockedTarget = player; // The target object to follow

        // Add a physics impostor for the player
        player.physicsImpostor = new BABYLON.PhysicsImpostor(
            player,
            BABYLON.PhysicsImpostor.SphereImpostor, // Approximates the player as a sphere for physics
            { mass: 1, friction: 0.5, restitution: 0 },
            scene
        );


        // Load animations
        var animations = result.animationGroups;
        idleAnimation = animations.find((anim) => anim.name === "Idle");
        walkAnimation = animations.find((anim) => anim.name === "Walk");
        runAnimation = animations.find((anim) => anim.name === "Run");
        jumpAnimation = animations.find((anim) => anim.name === "Jump");

        // Start idle animation by default
        if (idleAnimation) idleAnimation.start(true);

        // Movement Logic
        var keys = { forward: false, backward: false, left: false, right: false, run: false, jump: false };
        var moveSpeed = 2; // Adjust movement speed for physics
        var runSpeed = 4;

        window.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = true;
                    break;
                case "s":
                    keys.backward = true;
                    break;
                case "a":
                    keys.left = true;
                    break;
                case "d":
                    keys.right = true;
                    break;
                case "Shift":
                    keys.run = true;
                    break;
                case " ":
                    if (player.physicsImpostor && player.physicsImpostor.getLinearVelocity().y === 0) {
                        keys.jump = true;
                        player.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 5, 0)); // Apply upward force
                    }
                    break;
            }
        });

        window.addEventListener("keyup", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = false;
                    break;
                case "s":
                    keys.backward = false;
                    break;
                case "a":
                    keys.left = false;
                    break;
                case "d":
                    keys.right = false;
                    break;
                case "Shift":
                    keys.run = false;
                    break;
            }
        });

        // Movement and Animation Logic
        scene.onBeforeRenderObservable.add(() => {
            if (!player || !player.physicsImpostor) return;

            let moving = false;
            const currentSpeed = keys.run ? runSpeed : moveSpeed;

            const direction = new BABYLON.Vector3(
                (keys.left ? -1 : 0) + (keys.right ? 1 : 0),
                0,
                (keys.forward ? 1 : 0) + (keys.backward ? -1 : 0)
            );
            direction.normalize();

            if (direction.length() > 0) {
                moving = true;

                // Move player by applying force
                const moveForce = direction.scale(currentSpeed);
                player.physicsImpostor.setLinearVelocity(
                    new BABYLON.Vector3(moveForce.x, player.physicsImpostor.getLinearVelocity().y, moveForce.z)
                );

                // Rotate player to face movement direction
                player.rotation.y = Math.atan2(direction.x, direction.z);
            }

            // Play animations based on movement
            if (moving) {
                if (keys.run) {
                    if (runAnimation && !runAnimation.isPlaying) {
                        idleAnimation?.stop();
                        walkAnimation?.stop();
                        runAnimation.start(true);
                    }
                } else {
                    if (walkAnimation && !walkAnimation.isPlaying) {
                        idleAnimation?.stop();
                        runAnimation?.stop();
                        walkAnimation.start(true);
                    }
                }
            } else {
                if (!idleAnimation.isPlaying) {
                    walkAnimation?.stop();
                    runAnimation?.stop();
                    idleAnimation.start(true);
                }
            }
        });
    });

    return scene;
};
`;

        var test7 = `
var createScene = function () {
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.0);

    // Enable physics with gravity
    var gravityVector = new BABYLON.Vector3(0, -9.8, 0); // Earth's gravity
    var physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);

    // Camera Setup
    var camera = new BABYLON.FollowCamera("FollowCamera", new BABYLON.Vector3(0, 5, -10), scene);
    camera.attachControl(canvas, true);

    // Lighting
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Ground Setup
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 50, height: 50 }, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.5);
    ground.material = groundMaterial;
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(
        ground,
        BABYLON.PhysicsImpostor.PlaneImpostor, // Correct impostor for a flat ground
        { mass: 0, friction: 0.5, restitution: 0.7 },
        scene
    );

    // Stairs Setup
    var stairs = BABYLON.MeshBuilder.CreateBox("stairs", { width: 4, height: 1, depth: 6 }, scene);
    stairs.position = new BABYLON.Vector3(0, 0.5, 5);
    stairs.physicsImpostor = new BABYLON.PhysicsImpostor(
        stairs,
        BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, friction: 0.5, restitution: 0.7 },
        scene
    );

    // Character Setup
    let player, walkAnimation, idleAnimation, runAnimation, jumpAnimation;

    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "Soldier.glb", scene).then((result) => {
        player = result.meshes[0];
        player.position = new BABYLON.Vector3(0, 1, 0); // Start above ground
        player.scaling = new BABYLON.Vector3(1, 1, 1);

        camera.lockedTarget = player; // Follow player

        // Add a physics impostor for the player
        player.physicsImpostor = new BABYLON.PhysicsImpostor(
            player,
            BABYLON.PhysicsImpostor.SphereImpostor, // Approximates the player as a sphere for physics
            { mass: 1, friction: 0.5, restitution: 0 },
            scene
        );

        // Synchronize physics impostor with player position
        player.physicsImpostor.registerAfterPhysicsStep(() => {
            player.position = player.physicsImpostor.getObjectCenter();
        });

        // Load animations
        var animations = result.animationGroups;
        idleAnimation = animations.find((anim) => anim.name === "Idle");
        walkAnimation = animations.find((anim) => anim.name === "Walk");
        runAnimation = animations.find((anim) => anim.name === "Run");
        jumpAnimation = animations.find((anim) => anim.name === "Jump");

        // Start idle animation by default
        if (idleAnimation) idleAnimation.start(true);

        // Movement Logic
        var keys = { forward: false, backward: false, left: false, right: false, run: false, jump: false };
        var moveSpeed = 2; // Adjust movement speed for physics
        var runSpeed = 4;

        window.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = true;
                    break;
                case "s":
                    keys.backward = true;
                    break;
                case "a":
                    keys.left = true;
                    break;
                case "d":
                    keys.right = true;
                    break;
                case "Shift":
                    keys.run = true;
                    break;
                case " ": // Space key for jump
                    if (player.physicsImpostor && player.physicsImpostor.getLinearVelocity().y === 0) {
                        keys.jump = true;
                        player.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 5, 0)); // Apply upward force
                    }
                    break;
            }
        });

        window.addEventListener("keyup", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = false;
                    break;
                case "s":
                    keys.backward = false;
                    break;
                case "a":
                    keys.left = false;
                    break;
                case "d":
                    keys.right = false;
                    break;
                case "Shift":
                    keys.run = false;
                    break;
            }
        });

        scene.onBeforeRenderObservable.add(() => {
    if (!player || !player.physicsImpostor) return;

    let moving = false;
    const currentSpeed = keys.run ? runSpeed : moveSpeed;

    const direction = new BABYLON.Vector3(
        (keys.left ? -1 : 0) + (keys.right ? 1 : 0),
        0,
        (keys.forward ? 1 : 0) + (keys.backward ? -1 : 0)
    );
    direction.normalize();

    if (direction.length() > 0) {
        moving = true;

        // Apply force to move the player
        const moveForce = direction.scale(currentSpeed * player.physicsImpostor.mass);
        player.physicsImpostor.applyForce(
            new BABYLON.Vector3(moveForce.x, 0, moveForce.z),
            player.getAbsolutePosition()
        );

        // Rotate player to face movement direction
        player.rotation.y = Math.atan2(direction.x, direction.z);
    }

    // Play animations based on movement
    if (moving) {
        if (keys.run) {
            if (runAnimation && !runAnimation.isPlaying) {
                idleAnimation?.stop();
                walkAnimation?.stop();
                runAnimation.start(true);
            }
        } else {
            if (walkAnimation && !walkAnimation.isPlaying) {
                idleAnimation?.stop();
                runAnimation?.stop();
                walkAnimation.start(true);
            }
        }
    } else {
        if (!idleAnimation.isPlaying) {
            walkAnimation?.stop();
            runAnimation?.stop();
            idleAnimation.start(true);
        }
    }
});

    });

    return scene;
};
`;

        var test8 = `
var createScene = function () {
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.0);

    // Enable physics with gravity
    var gravityVector = new BABYLON.Vector3(0, -9.8, 0); // Earth's gravity
    var physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);

    // Camera Setup
    var camera = new BABYLON.FollowCamera("FollowCamera", new BABYLON.Vector3(0, 5, -10), scene);
    camera.attachControl(canvas, true);

    // Lighting
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Ground Setup
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 50, height: 50 }, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.5);
    ground.material = groundMaterial;
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(
        ground,
        BABYLON.PhysicsImpostor.PlaneImpostor, // Correct impostor for a flat ground
        { mass: 0, friction: 0.5, restitution: 0.7 },
        scene
    );

    // Stairs Setup
    var stairs = BABYLON.MeshBuilder.CreateBox("stairs", { width: 4, height: 1, depth: 6 }, scene);
    stairs.position = new BABYLON.Vector3(0, 0.5, 5);
    stairs.physicsImpostor = new BABYLON.PhysicsImpostor(
        stairs,
        BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, friction: 0.5, restitution: 0.7 },
        scene
    );

    // Character Setup
    let player, walkAnimation, idleAnimation, runAnimation, jumpAnimation;

    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "Soldier.glb", scene).then((result) => {
        player = result.meshes[0];
        player.position = new BABYLON.Vector3(0, 1, 0); // Start above ground
        player.scaling = new BABYLON.Vector3(1, 1, 1);

        camera.lockedTarget = player; // Follow player

        // Add a physics impostor for the player
        player.physicsImpostor = new BABYLON.PhysicsImpostor(
            player,
            BABYLON.PhysicsImpostor.SphereImpostor, // Approximates the player as a sphere for physics
            { mass: 1, friction: 0.5, restitution: 0 },
            scene
        );

        // Synchronize physics impostor with player position
        player.physicsImpostor.registerAfterPhysicsStep(() => {
            player.position = player.physicsImpostor.getObjectCenter();
        });

        // Load animations
        var animations = result.animationGroups;
        idleAnimation = animations.find((anim) => anim.name === "Idle");
        walkAnimation = animations.find((anim) => anim.name === "Walk");
        runAnimation = animations.find((anim) => anim.name === "Run");
        jumpAnimation = animations.find((anim) => anim.name === "Jump");

        // Start idle animation by default
        if (idleAnimation) idleAnimation.start(true);

        // Movement Logic
        var keys = { forward: false, backward: false, left: false, right: false, run: false, jump: false };
        var moveSpeed = 2; // Adjust movement speed for physics
        var runSpeed = 4;

        window.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = true;
                    break;
                case "s":
                    keys.backward = true;
                    break;
                case "a":
                    keys.left = true;
                    break;
                case "d":
                    keys.right = true;
                    break;
                case "Shift":
                    keys.run = true;
                    break;
                case " ": // Space key for jump
                    if (player.physicsImpostor && player.physicsImpostor.getLinearVelocity().y === 0) {
                        keys.jump = true;
                        player.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 5, 0)); // Apply upward force
                    }
                    break;
            }
        });

        window.addEventListener("keyup", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = false;
                    break;
                case "s":
                    keys.backward = false;
                    break;
                case "a":
                    keys.left = false;
                    break;
                case "d":
                    keys.right = false;
                    break;
                case "Shift":
                    keys.run = false;
                    break;
            }
        });

       scene.onBeforeRenderObservable.add(() => {
    if (!player || !player.physicsImpostor) return;

    const currentSpeed = keys.run ? runSpeed : moveSpeed;
    const direction = new BABYLON.Vector3(
        (keys.left ? -1 : 0) + (keys.right ? 1 : 0),
        0,
        (keys.forward ? 1 : 0) + (keys.backward ? -1 : 0)
    );
    direction.normalize(); // Normalize the direction vector

    if (direction.length() > 0) {
        const velocity = player.physicsImpostor.getLinearVelocity();
        const newVelocity = new BABYLON.Vector3(
            direction.x * currentSpeed,
            velocity.y, // Preserve Y velocity for gravity and jumps
            direction.z * currentSpeed
        );

        player.physicsImpostor.setLinearVelocity(newVelocity); // Set the updated velocity

        // Rotate the player to face the movement direction
        player.rotation.y = Math.atan2(direction.x, direction.z);
    }

    // Animation logic
    const moving = direction.length() > 0;
    if (moving) {
        if (keys.run && runAnimation && !runAnimation.isPlaying) {
            idleAnimation?.stop();
            walkAnimation?.stop();
            runAnimation.start(true);
        } else if (!keys.run && walkAnimation && !walkAnimation.isPlaying) {
            idleAnimation?.stop();
            runAnimation?.stop();
            walkAnimation.start(true);
        }
    } else {
        if (idleAnimation && !idleAnimation.isPlaying) {
            walkAnimation?.stop();
            runAnimation?.stop();
            idleAnimation.start(true);
        }
    }
});

    });

    return scene;
};
`;

        var test9 = `var createScene = function () {
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.0);

    // Enable physics with gravity
    var gravityVector = new BABYLON.Vector3(0, -9.8, 0); // Earth's gravity
    var physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);

    // Camera Setup
    var camera = new BABYLON.FollowCamera("FollowCamera", new BABYLON.Vector3(0, 5, -10), scene);
    camera.attachControl(canvas, true);

    // Lighting
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Ground Setup
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 50, height: 50 }, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.5);
    ground.material = groundMaterial;
    
    // ground.physicsImpostor = new BABYLON.PhysicsImpostor(
    //     ground,
    //     BABYLON.PhysicsImpostor.PlaneImpostor, // Correct impostor for a flat ground
    //     { mass: 0, friction: 0.5, restitution: 0.7 },
    //     scene
    // );

//     ground.physicsImpostor = new BABYLON.PhysicsImpostor(
//     ground,
//     BABYLON.PhysicsImpostor.PlaneImpostor, // Use BoxImpostor for the ground
//     { mass: 0, friction: 0.5, restitution: 0.7 },
//     scene
// );
ground.physicsImpostor = new BABYLON.PhysicsImpostor(
    ground,
    BABYLON.PhysicsImpostor.BoxImpostor, // BoxImpostor for better collision
    { mass: 0, friction: 0.9, restitution: 0 },
    scene
);


   
    // Stairs Setup
    var stairs = BABYLON.MeshBuilder.CreateBox("stairs", { width: 4, height: 1, depth: 6 }, scene);
    stairs.position = new BABYLON.Vector3(0, 0.5, 5);
    stairs.physicsImpostor = new BABYLON.PhysicsImpostor(
        stairs,
        BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, friction: 0.5, restitution: 0.7 },
        scene
    );

    // Character Setup
    let player, walkAnimation, idleAnimation, runAnimation, jumpAnimation;

    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "Soldier.glb", scene).then((result) => {
        player = result.meshes[0];
        player.position = new BABYLON.Vector3(0, 1, 0); // Start above ground
        player.scaling = new BABYLON.Vector3(1, 1, 1);

        camera.lockedTarget = player; // Follow player

        // // Add a physics impostor for the player
        // player.physicsImpostor = new BABYLON.PhysicsImpostor(
        //     player,
        //     BABYLON.PhysicsImpostor.SphereImpostor, // Approximates the player as a sphere for physics
        //     { mass: 1, friction: 0.5, restitution: 0 },
        //     scene
        // );

        //     player.physicsImpostor = new BABYLON.PhysicsImpostor(
        // player,
       // BABYLON.PhysicsImpostor.BoxImpostor, // Use BoxImpostor for better collision handling
        // { mass: 1, friction: 0.5, restitution: 0 },
        // scene
          //);


            player.physicsImpostor = new BABYLON.PhysicsImpostor(
            player,
             BABYLON.PhysicsImpostor.BoxImpostor, // BoxImpostor for the player
               { mass: 1, friction: 0.5, restitution: 0 },
                scene
                   );


        // Synchronize physics impostor with player position
        player.physicsImpostor.registerAfterPhysicsStep(() => {
            player.position = player.physicsImpostor.getObjectCenter();
        });

        // Load animations
        var animations = result.animationGroups;
        idleAnimation = animations.find((anim) => anim.name === "Idle");
        walkAnimation = animations.find((anim) => anim.name === "Walk");
        runAnimation = animations.find((anim) => anim.name === "Run");
        jumpAnimation = animations.find((anim) => anim.name === "Jump");

        // Start idle animation by default
        if (idleAnimation) idleAnimation.start(true);

        // Movement Logic
        var keys = { forward: false, backward: false, left: false, right: false, run: false, jump: false };
        var moveSpeed = 2; // Adjust movement speed for physics
        var runSpeed = 4;
        var isJumping = false;

        window.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "w":
                    keys.forward = true;
                    break;
                case "s":
                    keys.backward = true;
                    break;
                case "a":
                    keys.left = true;
                    break;
                case "d":
                    keys.right = true;
                    break;
                case "Shift":
                    keys.run = true;
                    break;
                case " ": // Space key for jump
                    if (!isJumping && player.physicsImpostor.getLinearVelocity().y === 0) {
                        keys.jump = true;
                        isJumping = true;
                        player.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 5, 0), player.getAbsolutePosition());
                        if (jumpAnimation) {
                            walkAnimation?.stop();
                            runAnimation?.stop();
                            idleAnimation?.stop();
                            jumpAnimation.start(false, 1, jumpAnimation.from, jumpAnimation.to, false);
                        }
                    }
                    break;
            }
        });

        window.addEventListener("keyup", (event) => {
            console.log(\`\${event.key}\`);

            switch (event.key) {
                case "w":
                    keys.forward = false;
                    break;
                case "s":
                    keys.backward = false;
                    break;
                case "a":
                    keys.left = false;
                    break;
                case "d":
                    keys.right = false;
                    break;
                case "Shift":
                    keys.run = false;
                    break;
                case " ":
                    keys.jump = false;
                    break;
            }
        });

        

        scene.onBeforeRenderObservable.add(() => {
    if (player && player.physicsImpostor) {
        const velocity = player.physicsImpostor.getLinearVelocity();

        // Stop vertical fall when on the ground
        if (player.position.y <= 0.2 && velocity.y < 0) {
            player.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(velocity.x, 0, velocity.z));
            player.position.y = 0.2; // Snap player to ground level to prevent sinking
        }
         }
      });

scene.onBeforeRenderObservable.add(() => {
    if (!player || !player.physicsImpostor) return;

    const velocity = player.physicsImpostor.getLinearVelocity();
    const grounded = player.position.y <= 1.1; // Check if player is on the ground

    const currentSpeed = keys.run ? runSpeed : moveSpeed;
    const direction = new BABYLON.Vector3(
        (keys.left ? -1 : 0) + (keys.right ? 1 : 0),
        0,
        (keys.forward ? 1 : 0) + (keys.backward ? -1 : 0)
    );
    direction.normalize();

    if (direction.length() > 0 && grounded) {
        const newVelocity = new BABYLON.Vector3(
            direction.x * currentSpeed,
            velocity.y, // Preserve Y velocity
            direction.z * currentSpeed
        );
        player.physicsImpostor.setLinearVelocity(newVelocity);

        // Rotate the player to face the movement direction
        player.rotation.y = Math.atan2(direction.x, direction.z);
    }

    // Handle Jump
    if (keys.jump && grounded) {
        player.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 10, 0), player.getAbsolutePosition());
        keys.jump = false; // Reset jump key
    }
});

        
    });

    return scene;
};
`;

        //loadSceneCode(test9);

        loadSceneCode(test1);
    </script>




</body>

</html>