<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Learn & Practice Notes</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <!-- Include Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <!-- Include Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <!-- Include JavaScript and Markup (HTML) support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>

    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.10/codemirror.min.css">

    <!-- CodeMirror JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.10/codemirror.min.js"></script>

    <!-- CodeMirror JavaScript Mode for JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.10/mode/javascript/javascript.min.js"></script>



</head>

<body>
    <!-- <canvas id="renderCanvas"></canvas>
    <nav>
        <button id="scene1">Load Scene 1</button>
        <button id="scene2">Load Scene 2</button>
    </nav> -->
    <!-- <script src="js/common.js"></script>
    <script src="js/main.js"></script>
    <script src="js/map_pattern.js"></script>
    <script src="js/hierarchy.js"></script>

    <div id="hierarchicalStructure"></div> -->

    <!-- Main content -->
    <script src="js/code_1_25.js"></script>
    <script src="js/code_26_50.js"></script>
    <script src="js/code_51_75.js"></script>


    <script src="js/map_pattern.js"></script>
    <script src="js/page_mapper.js"></script>
    <script src="js/code_list.js"></script>
    <script src="js/hierarchy.js"></script>
    <script src="js/common.js"></script>



    <div id="mySidebar" class="sidebar">
        Gobal Krishnan V <br>
        <address>gobalkrishnan.books@gmail.com</address>

        <div id="hierarchicalStructure"></div>
    </div>

    <div id="main">


        <canvas id="renderCanvas"></canvas>


        <!-- Code Modal -->
        <div id="codeModal">
            <button id="closeCodeModal">Close</button>

            <!-- <pre id="codeDisplay"><code class="language-javascript">// Code will appear here</code></pre>
       -->
            <div id="codeEditor"></div>
            <button id="runCodeButton">Run Code</button>

        </div>

        <!-- View Code Button -->
        <button id="toggleCodeButton">View Code</button>





        <button id="toggleButton" class="toggle-btn">☰</button>
        <!-- <div id="canvasZone"><canvas id="renderCanvas"></canvas></div> -->



    </div>



    <script>
        // Toggle the sidebar
        function toggleSidebar() {
            var sidebar = document.getElementById("mySidebar");
            var main = document.getElementById("main");
            var button = document.getElementById("toggleButton");

            var width = "400px";
            if (sidebar.style.width === width) {
                // Close the sidebar
                sidebar.style.width = "0";
                main.style.marginLeft = "0";
                button.textContent = "☰";
            } else {
                // Open the sidebar
                sidebar.style.width = width;
                main.style.marginLeft = width;
                button.textContent = "x";
            }
        }

        // Attach toggle function to the button
        document.getElementById("toggleButton").addEventListener("click", toggleSidebar);
    </script>

    <script>
        var test1 = `
var createScene = function () {
    // Create the scene
    var scene = new BABYLON.Scene(engine);

    // Set the background color to white
    scene.clearColor = new BABYLON.Color4(1, 1, 1, 1); // RGBA for white

    // Add a camera
    var camera = new BABYLON.ArcRotateCamera(
        "camera",
        -Math.PI / 2,
        Math.PI / 2.5,
        50,
        new BABYLON.Vector3(0, 0, 0)
    );
    camera.attachControl(canvas, true);

    // Add a light
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

    //var music = new BABYLON.Sound("cello", "sound/16.wav", scene, null, { loop: true, autoplay: true,volume:1 });

   
    
    // Load the 3D model
    BABYLON.SceneLoader.ImportMeshAsync("", "3dmodel/", "house_dancing.glb", scene)
        .then((result) => {
            var dude = result.meshes[0]; // The root mesh
            dude.scaling = new BABYLON.Vector3(10.0, 10.0, 10.0);

            // Center the object
            var boundingInfo = dude.getBoundingInfo();
            var center = boundingInfo.boundingBox.centerWorld;

            // Translate the object to center it
            dude.position = dude.position.subtract(center);

            // Begin animation if skeletons are available
            if (result.skeletons.length > 0) {
                scene.beginAnimation(result.skeletons[0], 0, 100, true, 1.0);
            }

            // Add Text Overlay
            addOverlayText(scene);
        })
        .catch((error) => {
            console.error("Failed to load model:", error);
        });

    return scene;
};

// Function to add overlay text
function addOverlayText(scene) {
    // Create an advanced dynamic texture for overlay
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    // Add the "Babylon.js" text with gradient
    var babylonText = new BABYLON.GUI.TextBlock();
    babylonText.text = "Babylon.js";
    babylonText.color = "black";
    babylonText.fontSize = "50px";
    babylonText.fontWeight = "bold";
    babylonText.top = "200px"; // Position below the model
    advancedTexture.addControl(babylonText);

    // Add "Gobal Krishnan V" text
    var nameText = new BABYLON.GUI.TextBlock();
    nameText.text = "Gobal Krishnan V";
    nameText.color = "black";
    nameText.fontSize = "20px";
    nameText.top = "250px"; // Position below the Babylon.js text
    advancedTexture.addControl(nameText);

    // Add email text
    var emailText = new BABYLON.GUI.TextBlock();
    emailText.text = "gobalkrishnan.books@gmail.com";
    emailText.color = "gray";
    emailText.fontSize = "15px";
    emailText.top = "280px"; // Position below the name
    advancedTexture.addControl(emailText);
}
//orange
`;
        var c1 =
            `var createScene = function () {
        // This creates a basic Babylon Scene object (non-mesh)
        var scene = new BABYLON.Scene(engine);
    
        // This creates and positions a free camera (non-mesh)
        var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    
        // This targets the camera to scene origin
        camera.setTarget(BABYLON.Vector3.Zero());
    
        // This attaches the camera to the canvas
        camera.attachControl(canvas, true);
    
        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    
        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 0.7;
    
        // Our built-in 'ground' shape.
        var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    
        return scene;
    }; `;


    var test2 = `
    var createScene = function () {
    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -5), scene);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    // Initialize Havok plugin
    const hk = new BABYLON.HavokPlugin(false);

    // Enable physics in the scene with a gravity
    scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

    // Load GLB exported from Blender using Physics extension enabled
    BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/CedricGuillemet/dump/master/CharController/", "levelTest.glb", scene).then(()=>{
        // Load a texture that will be used as lightmap. This Lightmap was made using this process : https://www.youtube.com/watch?v=Q4Ajd06eTak
        var lightmap = new BABYLON.Texture("https://raw.githubusercontent.com/CedricGuillemet/dump/master/CharController/lightmap.jpg");
        // Meshes using the lightmap
        var lightmapped = ["level_primitive0", "level_primitive1", "level_primitive2"];
        lightmapped.forEach((meshName)=>{
            var mesh = scene.getMeshByName(meshName);
            // Create static physics shape for these particular meshes
            new BABYLON.PhysicsAggregate(mesh, BABYLON.PhysicsShapeType.MESH);
            mesh.isPickable = false;  
            mesh.material.lightmapTexture = lightmap;
            mesh.material.useLightmapAsShadowmap = true;
            mesh.material.lightmapTexture.uAng = Math.PI;
            mesh.material.lightmapTexture.level = 1.6;
            mesh.material.lightmapTexture.coordinatesIndex = 1;  
            mesh.freezeWorldMatrix();
            mesh.doNotSyncBoundingInfo = true;
        });
        // static physics cubes
        var cubes = ["Cube", "Cube.001", "Cube.002", "Cube.003", "Cube.004", "Cube.005"];
        cubes.forEach((meshName)=>{
            new BABYLON.PhysicsAggregate(scene.getMeshByName(meshName), BABYLON.PhysicsShapeType.BOX, {mass:0.1});
        });
        // inclined plane
        var planeMesh = scene.getMeshByName("Cube.006");
        planeMesh.scaling.set(0.03,3,1);
        var fixedMass = new BABYLON.PhysicsAggregate(scene.getMeshByName("Cube.007"), BABYLON.PhysicsShapeType.BOX, {mass:0});
        var plane = new BABYLON.PhysicsAggregate(planeMesh, BABYLON.PhysicsShapeType.BOX, {mass:0.1});

        // plane joint
        var joint = new BABYLON.HingeConstraint(
            new BABYLON.Vector3(0.75, 0, 0),
            new BABYLON.Vector3(-0.25, 0, 0),
            new BABYLON.Vector3(0, 0, -1),
            new BABYLON.Vector3(0, 0, 1),
            scene);
        fixedMass.body.addConstraint(plane.body, joint);

        // Player/Character state
        var state = "IN_AIR";
        var inAirSpeed = 8.0;
        var onGroundSpeed = 10.0;
        var jumpHeight = 1.5;
        var wantJump = false;
        var inputDirection = new BABYLON.Vector3(0,0,0);
        var forwardLocalSpace = new BABYLON.Vector3(0, 0, 1);
        let characterOrientation = BABYLON.Quaternion.Identity();
        let characterGravity = new BABYLON.Vector3(0, -18, 0);

        // Physics shape for the character
        let h = 1.8;
        let r = 0.6;
        let displayCapsule = BABYLON.MeshBuilder.CreateCapsule("CharacterDisplay", {height: h, radius: r}, scene);
        let characterPosition = new BABYLON.Vector3(3., 0.3, -8.);
        let characterController = new BABYLON.PhysicsCharacterController(characterPosition, {capsuleHeight: h, capsuleRadius: r}, scene);
        camera.setTarget(characterPosition);

        // State handling
        // depending on character state and support, set the new state
        var getNextState = function(supportInfo) {
            if (state == "IN_AIR") {
                if (supportInfo.supportedState == BABYLON.CharacterSupportedState.SUPPORTED) {
                    return "ON_GROUND";
                }
                return "IN_AIR";
            } else if (state == "ON_GROUND") {
                if (supportInfo.supportedState != BABYLON.CharacterSupportedState.SUPPORTED) {
                    return "IN_AIR";
                }

                if (wantJump) {
                    return "START_JUMP";
                }
                return "ON_GROUND";
            } else if (state == "START_JUMP") {
                return "IN_AIR";
            }
        }

        // From aiming direction and state, compute a desired velocity
        // That velocity depends on current state (in air, on ground, jumping, ...) and surface properties
        var getDesiredVelocity = function(deltaTime, supportInfo, characterOrientation, currentVelocity) {
            let nextState = getNextState(supportInfo);
            if (nextState != state) {
                state = nextState;
            }

            let upWorld = characterGravity.normalizeToNew();
            upWorld.scaleInPlace(-1.0);
            let forwardWorld = forwardLocalSpace.applyRotationQuaternion(characterOrientation);
            if (state == "IN_AIR") {
                let desiredVelocity = inputDirection.scale(inAirSpeed).applyRotationQuaternion(characterOrientation);
                let outputVelocity = characterController.calculateMovement(deltaTime, forwardWorld, upWorld, currentVelocity, BABYLON.Vector3.ZeroReadOnly, desiredVelocity, upWorld);
                // Restore to original vertical component
                outputVelocity.addInPlace(upWorld.scale(-outputVelocity.dot(upWorld)));
                outputVelocity.addInPlace(upWorld.scale(currentVelocity.dot(upWorld)));
                // Add gravity
                outputVelocity.addInPlace(characterGravity.scale(deltaTime));
                return outputVelocity;
            } else if (state == "ON_GROUND") {
                // Move character relative to the surface we're standing on
                // Correct input velocity to apply instantly any changes in the velocity of the standing surface and this way
                // avoid artifacts caused by filtering of the output velocity when standing on moving objects.
                let desiredVelocity = inputDirection.scale(onGroundSpeed).applyRotationQuaternion(characterOrientation);

                let outputVelocity = characterController.calculateMovement(deltaTime, forwardWorld, supportInfo.averageSurfaceNormal, currentVelocity, supportInfo.averageSurfaceVelocity, desiredVelocity, upWorld);
                // Horizontal projection
                {
                    outputVelocity.subtractInPlace(supportInfo.averageSurfaceVelocity);
                    let inv1k = 1e-3;
                    if (outputVelocity.dot(upWorld) > inv1k) {
                        let velLen = outputVelocity.length();
                        outputVelocity.normalizeFromLength(velLen);

                        // Get the desired length in the horizontal direction
                        let horizLen = velLen / supportInfo.averageSurfaceNormal.dot(upWorld);

                        // Re project the velocity onto the horizontal plane
                        let c = supportInfo.averageSurfaceNormal.cross(outputVelocity);
                        outputVelocity = c.cross(upWorld);
                        outputVelocity.scaleInPlace(horizLen);
                    }
                    outputVelocity.addInPlace(supportInfo.averageSurfaceVelocity);
                    return outputVelocity;
                }
            } else if (state == "START_JUMP") {
                let u = Math.sqrt(2 * characterGravity.length() * jumpHeight);
                let curRelVel = currentVelocity.dot(upWorld);
                return currentVelocity.add(upWorld.scale(u - curRelVel));
            }
            return Vector3.Zero();
        }

        // Display tick update: compute new camera position/target, update the capsule for the character display
        scene.onBeforeRenderObservable.add((scene) => {
            displayCapsule.position.copyFrom(characterController.getPosition());

            // camera following
            var cameraDirection = camera.getDirection(new BABYLON.Vector3(0,0,1));
            cameraDirection.y = 0;
            cameraDirection.normalize();
            camera.setTarget(BABYLON.Vector3.Lerp(camera.getTarget(), displayCapsule.position, 0.1));
            var dist = BABYLON.Vector3.Distance(camera.position, displayCapsule.position);
            const amount = (Math.min(dist - 6, 0) + Math.max(dist - 9, 0)) * 0.04;
            cameraDirection.scaleAndAddToRef(amount, camera.position);
            camera.position.y += (displayCapsule.position.y + 2 - camera.position.y) * 0.04;
        });

        // After physics update, compute and set new velocity, update the character controller state
        scene.onAfterPhysicsObservable.add((_) => {
            if (scene.deltaTime == undefined) return;
            let dt = scene.deltaTime / 1000.0;
            if (dt == 0) return;

            let down = new BABYLON.Vector3(0, -1, 0);
            let support = characterController.checkSupport(dt, down);

            BABYLON.Quaternion.FromEulerAnglesToRef(0,camera.rotation.y, 0, characterOrientation);
            let desiredLinearVelocity = getDesiredVelocity(dt, support, characterOrientation, characterController.getVelocity());
            characterController.setVelocity(desiredLinearVelocity);

            characterController.integrate(dt, support, characterGravity);
        });

        // Rotate camera
        // Add a slide vector to rotate arount the character
        let isMouseDown = false;
        scene.onPointerObservable.add((pointerInfo) => {
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    isMouseDown = true;
                    break;

                case BABYLON.PointerEventTypes.POINTERUP:
                    isMouseDown = false;
                    break;

                case BABYLON.PointerEventTypes.POINTERMOVE:
                    if (isMouseDown) {
                        var tgt = camera.getTarget().clone();
                        camera.position.addInPlace(camera.getDirection(BABYLON.Vector3.Right()).scale(pointerInfo.event.movementX * -0.02));
                        camera.setTarget(tgt);
                    }
                    break;
            }
        });
        // Input to direction
        // from keys down/up, update the Vector3 inputDirection to match the intended direction. Jump with space
        scene.onKeyboardObservable.add((kbInfo) => {
            switch (kbInfo.type) {
                case BABYLON.KeyboardEventTypes.KEYDOWN:
                    if (kbInfo.event.key == 'w' || kbInfo.event.key == 'ArrowUp') {
                        inputDirection.z = 1;
                    } else if (kbInfo.event.key == 's' || kbInfo.event.key == 'ArrowDown') {
                        inputDirection.z = -1;
                    } else if (kbInfo.event.key == 'a' || kbInfo.event.key == 'ArrowLeft') {
                        inputDirection.x = -1;
                    } else if (kbInfo.event.key == 'd' || kbInfo.event.key == 'ArrowRight') {
                        inputDirection.x = 1;
                    } else if (kbInfo.event.key == ' ') {
                        wantJump = true;
                    }
                    break;
                case BABYLON.KeyboardEventTypes.KEYUP:
                    if (kbInfo.event.key == 'w' || kbInfo.event.key == 's' || kbInfo.event.key == 'ArrowUp' || kbInfo.event.key == 'ArrowDown') {
                        inputDirection.z = 0;    
                    }
                    if (kbInfo.event.key == 'a' || kbInfo.event.key == 'd' || kbInfo.event.key == 'ArrowLeft' || kbInfo.event.key == 'ArrowRight') {
                        inputDirection.x = 0;
                    } else if (kbInfo.event.key == ' ') {
                        wantJump = false;
                    }
                    break;
            }
        });
        
    });
                        addOverlayText(scene);

    return scene;
};

// Function to add overlay text
function addOverlayText(scene) {
    // Create an advanced dynamic texture for overlay
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    // Add the "Babylon.js" text with gradient
    var babylonText = new BABYLON.GUI.TextBlock();
    babylonText.text = "Babylon.js";
    babylonText.color = "black";
    babylonText.fontSize = "50px";
    babylonText.fontWeight = "bold";
    babylonText.top = "200px"; // Position below the model
    advancedTexture.addControl(babylonText);

    // Add "Gobal Krishnan V" text
    var nameText = new BABYLON.GUI.TextBlock();
    nameText.text = "Gobal Krishnan V";
    nameText.color = "black";
    nameText.fontSize = "20px";
    nameText.top = "250px"; // Position below the Babylon.js text
    advancedTexture.addControl(nameText);

    // Add email text
    var emailText = new BABYLON.GUI.TextBlock();
    emailText.text = "gobalkrishnan.books@gmail.com";
    emailText.color = "gray";
    emailText.fontSize = "15px";
    emailText.top = "280px"; // Position below the name
    advancedTexture.addControl(emailText);
}

    `;     



        loadSceneCode(test2);
    </script>




</body>

</html>